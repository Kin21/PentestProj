import time

import networkx
import socket
import ipaddress
import platform
import subprocess
import nmap
from anytree import Node, PreOrderIter
from anytree.exporter import DotExporter

class DataNode:
    full_nodes = []
    exec_tree_root = Node('Start')

    def __init__(self, g):
        self.g = g
        self.functions = []

    def report(self):
        return

    def _add_object_functions(self, obj, *functions):
        for f in functions:
            self.g.add_edge(obj, f, isfunction=True)

    def add_functions(self, *functions):
        for f in functions:
            self.g.add_edge(self, f, isfunction=True)

    def check_neighbor_links(self, data):
        return data not in [i for i in self.g.neighbors(self)]

    def add_data(self, *data):
        for d in data:
            if self.check_neighbor_links(d):
                print(' + New object found', d)
                self.g.add_edge(self, d, isfunction=False)
                self._add_object_functions(d, *d.functions)

    def run(self):
        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if t['isfunction']:
                obj()
                self.g.remove_node(obj)
                # Create execution tree
                last_function = list(PreOrderIter(type(self).exec_tree_root))[-1]
                Node(obj.__qualname__, parent=last_function)
                #
        self.end()
        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if not t['isfunction']:
                if obj not in type(self).full_nodes:
                    obj.run()

    def save_execution_tree(self):
        # Save execution tree
        DotExporter(type(self).exec_tree_root).to_dotfile('Execution_tree-{}.dot'.format(str(int(time.time()))))

    def end(self):
        edges_list = dict(self.g[self]).items()
        for obj, t in edges_list:
            if t['isfunction']:
                return False
        if self not in type(self).full_nodes:
            type(self).full_nodes.append(self)
        print(' -', self, 'Finished')
        return True


class Domain(DataNode):
    def __init__(self, g, domain):
        super().__init__(g)
        self.domain = domain
        self.functions = [self.getIP]

    def __str__(self):
        return 'Domain: {}'.format(self.domain)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return self.domain == other.domain

    def __hash__(self):
        return hash(self.domain)

    def getIP(self):
        print('Resolving domain name')
        ip_addr = socket.gethostbyname(self.domain)
        ip_addr = ipaddress.ip_address(ip_addr)
        ip = HostIP(self.g, ip_addr)
        self.add_data(ip)


class Service(DataNode):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g)
        self.port = port
        self.state = state
        self.transport = transport
        self.proto_name = proto_name
        self.product = product
        self.version = version
        self.extrainfo = extrainfo
        self.script_info = script_info
        self.functions = []

    def __str__(self):
        return self.proto_name

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return (str(self.port) + self.proto_name) == (str(other.port) + other.proto_name)

    def __hash__(self):
        return hash(str(self.port) + self.proto_name)

class SSH(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class HTTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class FTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class HostIP(DataNode):
    def __init__(self, g, ip):
        super().__init__(g)
        self.ip = ip
        self.alive = None
        self.vendor = None
        self.functions = [self.checkIfAlive, self.getDomain, self.scanSevices]

    def __str__(self):
        return 'Host: {}'.format(str(self.ip))

    def __eq__(self, other):
        if not isinstance(other, HostIP):
            return False
        return str(self.ip) == str(other.ip)

    def __hash__(self):
        return hash(self.ip)

    def _ping(self):
        host = str(self.ip)
        param = '-n' if platform.system().lower() == 'windows' else '-c'
        command = ['ping', param, '1', host]
        return subprocess.call(command) == 0

    def _nmap_alive_check(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        return True if nm[str(self.ip)].state() == 'up' else False

    def checkIfAlive(self):
        print('Checking if host {} is up'.format(str(self.ip)))
        #p1 = self._ping()
        p2 = self._nmap_alive_check()
        self.alive = p2

    def getDomain(self):
        print('Performing reverse DNS lookup')
        d = socket.gethostbyaddr(str(self.ip))[0]
        d = Domain(self.g, d)
        self.add_data(d)

    def _nmap_port_scan(self):
        return
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-Pn -F -A')
        scan_info = nm[str(self.ip)]
        for transport_proto in scan_info.all_protocols():
            for port in scan_info[transport_proto].keys():
                name = scan_info[transport_proto][port]['name']
                state = scan_info[transport_proto][port]['state']
                product = scan_info[transport_proto][port]['product']
                version = scan_info[transport_proto][port]['version']
                extrainfo = scan_info[transport_proto][port]['extrainfo']
                script_info = scan_info[transport_proto][port]['script']

                match state, name:
                    case 'open', 'ssh':
                        ssh = SSH(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(ssh)
                    case 'open', 'ftp':
                        ftp = FTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(ftp)
                    case 'open', 'http':
                        http = HTTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(http)

    def scanSevices(self):
        if self.alive == None:
            self.add_functions(self.scanSevices)
            return

        print('Start services scanning')
        if self.alive == False:
            return
        self._nmap_port_scan()






class Test(DataNode):
    def __init__(self, g):
        super().__init__(g)
        self.functions = []
        self.target = HostIP(g, '45.33.32.156')
        self.g.add_node(self, isfunction=False)
        self.add_data(self.target)

    def __str__(self):
        return 'Root Object'


g = networkx.Graph()
t = Test(g)
t.run()
t.save_execution_tree()
# h = t.target
# h.run()
# d = list(g.nodes)[2]
# g = networkx.Graph()
# h = HostIP(g, '127.0.0.1')
# g.add_node(h)
#h.run()
# d = list(g[h])[0]
# d.run()