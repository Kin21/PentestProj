import time
from bs4 import BeautifulSoup
import pandas as pd
import csv
import json
import requests
import subprocess
import os
import re
import gzip

from global_data import msfrpc_password, msf4_dir_path, searchsploit_path, exploit_db_path, msf_client

# 1. CPE -> CVE -> Exploits (Exploits requires different setups and arguments, hard to execute automatically,
#    but CVE list can be useful for further investigation)
# 2. CVE -> Metasploit exploit (Executed automatically); False-positive->0, false-negative->?
# 3. Searchsploit -> Specific Exploits(Only that can be executed automatically) -> Metasploit (Executed automatically)
#    This approach can cause false-positives


class VulnerabilityMapper:
    def __init__(self):
        print('Initializing database')
        # Search vulnerability by cpe
        self.nvd_cpe_api_url = 'https://services.nvd.nist.gov/rest/json/cpes/1.0/'
        self.nvd_cpe_parameters = {'cpeMatchString': None, 'addOns': 'cves', 'resultsPerPage': '100'}
        self.circl_api_url = 'https://cve.circl.lu/api/cvefor/{}'

        # Exploits to CVE map
        self.cve_to_explot_file = 'Exploit_CVE.json'
        self.NVD_local_file = 'NVD_Feeds.json'
        self.cve_to_metaslpoit_file = 'cve_to_metasploit.json'
        self.cve_to_metaslpoit_map = self.load_metasploit_map()
        self.exploit_to_cve_map = self._create_cve_to_exploit_map()
        self.nvd_cve_data = self._load_nvd_data()

    def _load_nvd_data(self):
        with open(self.NVD_local_file) as f:
            data = json.load(f)
        return data

    def load_metasploit_map(self):
        try:
            with open(self.cve_to_metaslpoit_file) as f:
                return json.load(f)
        except FileNotFoundError:
            self._map_cve_to_exploit_from_metasploit()
            return self.load_metasploit_map()

    def cpe_to_cve(self, cpe):
        # https://nvd.nist.gov/developers/start-here
        # Rate Limits
        #
        # Requesting an API key allows for users to make a greater number of requests in a given time than they
        # could otherwise. The public rate limit (without an API key) is 10 requests in a rolling 60 second window;
        # the rate limit with an API key is 100 requests in a rolling 60 second window.
        self.nvd_cpe_parameters['cpeMatchString'] = cpe
        data = requests.get(self.nvd_cpe_api_url, params=self.nvd_cpe_parameters)
        try:
            data = data.json()
        except requests.exceptions.JSONDecodeError:
            print('Must sleep for 60 seconds due to API restrictions')
            time.sleep(61)
            return self.cpe_to_cve(cpe)
        possible_vulnerabilities = []
        for res in data['result']['cpes']:
            possible_vulnerabilities += res['vulnerabilities']
        return list(set(possible_vulnerabilities))

    def cve_to_exploits(self, cve):
        with open(self.cve_to_explot_file) as f:
            data = json.load(f)
        exploits = []
        for obj in data:
            if obj['CveId'] == cve:
                exploits.append(obj['ExploitId'])
        return exploits

    def _map_cve_to_exploit_from_metasploit(self):
        global msfrpc_password
        global msf_client
        mc = msf_client
        exploits = mc.modules.exploits
        data = {}
        for e in exploits:
            exploit = mc.modules.use('exploit', e)
            ref = exploit.references
            if ref and ref[0][0] == 'CVE':
                linked_cve = '-'.join(ref[0])
                try:
                    existed_exploit = data[linked_cve]
                    existed_exploit.append(e)
                    data.update({linked_cve: existed_exploit})
                except KeyError:
                    data.update({linked_cve: [e]})
        with open(self.cve_to_metaslpoit_file, 'w') as f:
            json.dump(data, f)

    def get_metasploit_exploit_by_cve(self, cve, **search_info):
        try:
            # List of possible operating systems that we are interested in.
            os = search_info['os']
        except KeyError:
            os = None
        try:
            exploits = self.cve_to_metaslpoit_map[cve]
            # If OS is specified, returns only exploit for this OS
            if os:
                exploits = [e for e in exploits if (e.split('/')[0] in os) or (e.split('/')[0] == 'multi')]
            return exploits
        except KeyError:
            return []

    def get_cve_by_exploit(self, exploit):
        cve_name = ''
        try:
            cve_name = self.exploit_to_cve_map[exploit]
        except KeyError:
            exploit = exploit.split('/')[-1]
            with open(self.cve_to_explot_file) as f:
                data = json.load(f)
            for obj in data:
                if obj['ExploitId'] == exploit:
                    cve_name = obj['CveId']
        if not cve_name:
            return 'Exploit:' + exploit, {'Exploit': exploit, 'Exploit link': 'https://www.exploit-db.com/exploits/' + exploit}
        for obj in self.nvd_cve_data:
            if obj['CveId'] == cve_name:
                return cve_name, obj

    def _create_cve_to_exploit_map(self):
        res = {}
        for cve in self.cve_to_metaslpoit_map.keys():
            for e in self.cve_to_metaslpoit_map[cve]:
                res.update({
                    e: cve})
        return res

    def _update_metasploit(self):
        subprocess.run(['sudo', 'msfupdate'])

    def _search_sploit_update(self):
        global searchsploit_path
        subprocess.run([searchsploit_path, '-u'])

    def update(self):
        self.collect_exploit()
        self._update_metasploit()
        self._map_cve_to_exploit_from_metasploit()
        self._search_sploit_update()
        self.collect_nvd_feeds()

    def searchsploit_find(self, *searchdata, **search_criteria):
        try:
            os = search_criteria['os']
            if 'linux' in os:
                os.append('unix')
            os += 'multi'
        except KeyError:
            os = None
        searchdata = [str(i) for i in searchdata]
        temp = []
        for i in searchdata:
            temp.append(i)
            temp.append(' ')
        searchdata = temp
        global searchsploit_path
        result = subprocess.run([searchsploit_path] + searchdata, capture_output=True)
        search_res = result.stdout.decode(encoding='utf-8')
        # Check if exploits exist for given search query
        if result.stderr or 'Exploits: No Results' in search_res:
            return []
        # Derive only .rb exploit that can be automatically run with metasploit
        exploits = [e for e in search_res.split() if '.rb' in e]
        # We want remote exploit for specific OS
        if os:
            exploits = [e for e in exploits if e.split('/')[0] in os]
        exploits = [self._delete_ansi_escape(e) for e in exploits if e.split('/')[1] == 'remote']
        restart_needed = False
        for e in exploits:
            restart_needed |= self._add_to_metasploit(e)
        if restart_needed:
            self._msfrpcd_restart()
        exploits = ['pentest_proj/' + e.split('/')[-1].split('.')[0] for e in exploits]
        return exploits

    def _check_metasploit_presence(self, exploit_file_name):
        return exploit_file_name in os.listdir(msf4_dir_path)

    def _delete_ansi_escape(self, text):
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        return ansi_escape.sub('', text)

    def _add_to_metasploit(self, exploit_path):
        global msf4_dir_path
        global exploit_db_path
        exploit_file_name = exploit_path.split('/')[-1]
        if self._check_metasploit_presence(exploit_file_name):
            return False
        arg_str = 'cp ' + exploit_db_path + '/exploits/' + exploit_path + ' ' + msf4_dir_path + '/' + exploit_file_name
        subprocess.run([arg_str], shell=True)
        return True

    def _msfrpcd_restart(self):
        print('New exploits found, restarting msfrpcd...')
        try:
            res = subprocess.run(['sudo lsof -i -P -n | grep 55553'], shell=True, capture_output=True)
            PID = res.stdout.decode(encoding='utf-8').split()[1]
        except IndexError:
            PID = None
        if PID:
            subprocess.run(['sudo kill -9' + PID], shell=True)
        global msfrpc_password
        subprocess.run(['/opt/metasploit-framework/bin/msfrpcd', '-P', msfrpc_password, '-S'])

    # Function taken from https://github.com/nthnle/nvd-feeds-collection
    # Maps exploits from exploiDB to CVE numbers
    def collect_exploit(self):
        # print("Collecting CVE reference map for source EXPLOIT-DB")
        csv_file = open('Exploit_CVE.csv', 'w')
        csv_writer = csv.writer(csv_file)
        exploitUrl = 'https://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html'
        req = requests.get(exploitUrl, allow_redirects=True)
        # get status code
        # print("Exploit status code: " + str(req.status_code))
        # read the data from the URL and print it in html form
        # this is the full html, not just the table's html
        # we will need to parse through this to only grab the table we are interested in
        # use BeautifulSoup to parse through the html
        soup = BeautifulSoup(req.text, "html.parser")

        # find all the tables that fit these attributes
        # we only want the ExploitDB/CVENum table, so we index with [1] to grab table #2
        table = soup.findAll("table", attrs={"cellpadding": "2", "cellspacing": "2", "border": "2"})[1]

        # The first tr contains the field names.
        headings = ["ExploitId", "CveId"]
        datasets = []

        for row in table.find_all("tr")[0:]:
            row = list(td.get_text() for td in row.find_all("td"))
            # print(type(dataset))
            # df.append(dataset, ignore_index = True)
            # df = pd.DataFrame(dataset, columns=['ExploitDB Number', 'CVE Number'])
            datasets.append(row)
            # print(dataset)

        df = pd.DataFrame(datasets,
                          columns=headings)  # creating data frame with the proper headings and loading in the data
        df = df.astype('string')  # converting the pandas objects (default) to strings
        df.drop(df.tail(2).index, inplace=True)  # dropping the last two rows because they don't have exploit db Id's
        df[headings[0]] = df[headings[0]].str.replace(r'\D',
                                                      '')  # removing the prefix "EXPLOIT-DB" from the ExploitDBId column
        df[headings[1]] = df[headings[1]].str.rstrip("\n")  # removing the trailing newline from the CVEId column
        df[headings[1]] = df[headings[1]].str.lstrip(' ')  # removing the leading white space from the CVEId column
        df[headings[1]] = df[headings[1]].str.split(' ')  # splitting the column based on white space within the entries
        df = df.set_index([headings[0]])[headings[1]].apply(pd.Series).stack().reset_index().drop('level_1',
                                                                                                  axis=1).rename(
            columns={0: headings[1]})  # creating multiple rows for exploits that correspond to multiple CVE #'s

        n = len(df[headings[1]])  # find the number of rows in the dataframe
        csv_writer.writerow(headings)
        for i in range(n - 1):
            csv_writer.writerow(df.loc[i])  # writing data frame to a csv file

        csv_file.close()

        df.to_json(self.cve_to_explot_file, indent=2, orient='records')  # writing the dataframe to a json file

    # Function taken from https://github.com/nthnle/nvd-feeds-collection
    # Downloads and saves NVD CVE data
    def collect_nvd_feeds(self):
        print("Collecting JSON vulnerability feeds from NVD")
        nvdJson = []
        req = requests.get('https://nvd.nist.gov/vuln/data-feeds#JSON_FEED')

        # scan for all yearly gzip files
        for gzFile in re.findall("nvdcve-1.1-[0-9]*\.json\.gz", req.text):
            # print(gzFile)
            url = 'https://nvd.nist.gov/feeds/json/cve/1.1/' + gzFile
            reqFile = requests.get(url, stream=True, allow_redirects=True)
            # get status code
            print(gzFile + " status code: " + str(reqFile.status_code))
            # write response
            with open(gzFile, 'wb') as file:
                file.write(reqFile.content)
            with gzip.open(gzFile) as openGz:
                nvdDF = pd.read_json(openGz)
            for x in nvdDF['CVE_Items']:
                cveId = str(x['cve']['CVE_data_meta']['ID'])
                cveSrcUrl = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=' + cveId
                try:
                    cweId = str(x['cve']['problemtype']['problemtype_data'][0]['description'][0]['value'])
                except:
                    cweId = 'NONE_PROVIDED'
                try:
                    reference = str(x['cve']['references']['reference_data'][0]['url'])
                except:
                    reference = 'NONE_PROVIDED'
                try:
                    description = str(x['cve']['description']['description_data'][0]['value'])
                except:
                    description = 'NONE_PROVIDED'
                try:
                    cvssV2Version = str('CVSSv' + x['impact']['baseMetricV2']['cvssV2']['version'])
                    cvssV2AccessVector = str(x['impact']['baseMetricV2']['cvssV2']['accessVector'])
                    cvssV2AccessComplexity = str(x['impact']['baseMetricV2']['cvssV2']['accessComplexity'])
                    cvssV2Authentication = str(x['impact']['baseMetricV2']['cvssV2']['authentication'])
                    cvssV2ConfidentialityImpact = str(x['impact']['baseMetricV2']['cvssV2']['confidentialityImpact'])
                    cvssV2IntegrityImpact = str(x['impact']['baseMetricV2']['cvssV2']['integrityImpact'])
                    cvssV2AvailabilityImpact = str(x['impact']['baseMetricV2']['cvssV2']['availabilityImpact'])
                    cvssV2Score = float(x['impact']['baseMetricV2']['cvssV2']['baseScore'])
                    cvssV2Severity = str(x['impact']['baseMetricV2']['severity'])
                except:
                    cvssV2Version = 'NONE_PROVIDED'
                    cvssV2AccessVector = 'Unknown'
                    cvssV2AccessComplexity = 'Unknown'
                    cvssV2Authentication = 'Unknown'
                    cvssV2ConfidentialityImpact = 'Unknown'
                    cvssV2IntegrityImpact = 'Unknown'
                    cvssV2AvailabilityImpact = 'Unknown'
                    cvssV2Score = float(0.0)
                    cvssV2Severity = 'Unknown'
                try:
                    cvssV3Version = str('CVSSv' + x['impact']['baseMetricV3']['cvssV3']['version'])
                    cvssV3AttackVector = str(x['impact']['baseMetricV3']['cvssV3']['attackVector'])
                    cvssV3AttackComplexity = str(x['impact']['baseMetricV3']['cvssV3']['attackComplexity'])
                    cvssV3PrivilegesRequired = str(x['impact']['baseMetricV3']['cvssV3']['privilegesRequired'])
                    cvssV3UserInteraction = str(x['impact']['baseMetricV3']['cvssV3']['userInteraction'])
                    cvssV3Scope = str(x['impact']['baseMetricV3']['cvssV3']['scope'])
                    cvssV3ConfidentialityImpact = str(x['impact']['baseMetricV3']['cvssV3']['confidentialityImpact'])
                    cvssV3IntegrityImpact = str(x['impact']['baseMetricV3']['cvssV3']['integrityImpact'])
                    cvssV3AvailabilityImpact = str(x['impact']['baseMetricV3']['cvssV3']['availabilityImpact'])
                    cvssV3Score = float(x['impact']['baseMetricV3']['cvssV3']['baseScore'])
                    cvssV3Severity = str(x['impact']['baseMetricV3']['cvssV3']['baseSeverity'])
                except:
                    cvssV3Version = 'NONE_PROVIDED'
                    cvssV3AttackVector = 'Unknown'
                    cvssV3AttackComplexity = 'Unknown'
                    cvssV3PrivilegesRequired = 'Unknown'
                    cvssV3UserInteraction = 'Unknown'
                    cvssV3Scope = 'Unknown'
                    cvssV3ConfidentialityImpact = 'Unknown'
                    cvssV3IntegrityImpact = 'Unknown'
                    cvssV3AvailabilityImpact = 'Unknown'
                    cvssV3Score = float(0.0)
                    cvssV3Severity = 'Unknown'

                try:
                    nvdJson.append({
                        'CveId': cveId,
                        'CveSourceUrl': cveSrcUrl,
                        'CweId': cweId,
                        'Reference': reference,
                        'Description': description,
                        'CvssV2Version': cvssV2Version,
                        'CvssV2AccessVector': cvssV2AccessVector,
                        'CvssV2AccessComplexity': cvssV2AccessComplexity,
                        'CvssV2Authentication': cvssV2Authentication,
                        'CvssV2ConfidentialityImpact': cvssV2ConfidentialityImpact,
                        'CvssV2IntegrityImpact': cvssV2IntegrityImpact,
                        'CvssV2AvailabilityImpact': cvssV2AvailabilityImpact,
                        'CvssV2Score': cvssV2Score,
                        'CvssV2Severity': cvssV2Severity,
                        'CvssV3Version': cvssV3Version,
                        'CvssV3AttackVector': cvssV3AttackVector,
                        'CvssV3AttackComplexity': cvssV3AttackComplexity,
                        'CvssV3PrivilegesRequired': cvssV3PrivilegesRequired,
                        'CvssV3UserInteraction': cvssV3UserInteraction,
                        'CvssV3Scope': cvssV3Scope,
                        'CvssV3ConfidentialityImpact': cvssV3ConfidentialityImpact,
                        'CvssV3IntegrityImpact': cvssV3IntegrityImpact,
                        'CvssV3AvailabilityImpact': cvssV3AvailabilityImpact,
                        'CvssV3Score': cvssV3Score,
                        'CvssV3Severity': cvssV3Severity
                    })
                except Exception as e:
                    print(e)

        with open(self.NVD_local_file, "w") as file:
            json.dump(nvdJson, file)


class Filter:
    def __init__(self, **kwargs):
        self.ports_filter = self._get_arg(kwargs, 'ports_filter')
        self.cve_filter = self._get_arg(kwargs, 'cve_filter')

    def _get_arg(self, kwargs, arg):
        try:
            return kwargs[arg]
        except KeyError:
            return None

    def __call__(self, obj, *args, **kwargs):
        if not (bool(self.ports_filter) or bool(self.cve_filter)):
            self.default_filter(obj, *args, **kwargs)

    def default_filter(self, obj, *args, **kwargs):
        vuln_db = type(obj).vuln_mapper
        result = []
        for e in obj.exploits_to_run:
            try:
                cve_name, cve_obj = vuln_db.get_cve_by_exploit(e)
            except TypeError:
                continue
            if 'CVE' not in cve_name:
                continue
            score = float(cve_obj['CvssV3Score']) if float(cve_obj['CvssV3Score']) \
                else float(cve_obj['CvssV2Score'])
            result.append({e: score})
        result.sort(key=lambda el: list(el.values())[0])
        result = [list(el.keys())[0] for el in result]
        tail = list(set(obj.exploits_to_run) - set(result))
        obj.exploits_to_run = result + tail


if __name__ == '__main__':
    v = VulnerabilityMapper()
    cves = v.cpe_to_cve('cpe:/a:proftpd:proftpd:1.3.1')
    print(cves)
    for c in cves:
        print(v.cve_to_exploits(c))

